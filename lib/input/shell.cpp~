#include <Arduino.h>
#include <iostream>
#include <shell.h>



shell::shell(){
  __mode__=true;
  __SesTimeout__=30000;
  __row__="...digita help...";
} //costruttore di default





/*

  SerSrvMenu -  Serial Communication, get characters from  Serial (USB) Port
  ------------------------------------------------------------------------


  La funzione permette permette di acquisire una stringa digitata da tastiera.
  I caratteri digitati vengono memorizzati nell'array di carartteri receivedchars[] terminato
  dal carattere '\0' quando si preme il gtasto return.
  Per evitare lo sconfinamento dei limiti dell'array ad ogni pressione del tasto si incremnta l'indice 
  dell'array che quando raggiunge il limite massimo viene decrementato di uno di modo che 
  nell'ultima posizione ci sia sempre l'ultimo carattere digitato che alla pressione del tasto
  return viene sostituito dal carattere di escape '\0'.

  Inoltre vi Ã¨ un controlllo della durata del tempo di acquisiszione con il contatore che viene resettato ad ogni pressione di tasto.

  Infine l'impostazione a true della variabile HideEcho implica che il carattere digitato viene visualizzato
  con il carattere *.


  Ser_Rx()
  |
  +---[controllo del timeout]
  |
  +---[blocco di lettura]{
  |
  +----[blocco di acquisizione]

*/ 
string shell::read_Rx(boolean HideEcho) {

  unsigned long SessStart = millis();
  const byte numChars = MaxSerRx;
  char receivedChars[numChars];   // an array to store the received data
  boolean newData = false;
  static byte ndx = 0;
  char endMarker1 = '\r';         // Some terminal client apps send a CR
  char endMarker2 = '\n';         // Others just a LF character, therefore we need to check for both
  char rc;
  std::string __out__;
  
  Serial.flush();

  
  while (newData == false) { //blocco di lettura

    // controllo della durata della sessione di lettura
    if (millis() - SessStart > __SesTimeout__) { // blocco di controllo
      std::cout << "The session has timed out (";
      std::cout << (__SesTimeout__ / 1000);
      std::cout << " seconds)..." << std::endl;
      break;
    } // end of control block


    /* Ciclo di acquisizione della stringa. Si esegue fino a quando non si preme return.
       Ad ogni pressione del tasto si resetta il contatore del timeout.
       Alla pressione del tasto return */  
    while ( Serial.available()) {// blocco di acquisizione dei caratteri
      SessStart = millis();
       rc =  Serial.read();
       //std::cin >> rc;
      
      if (rc == endMarker1 or rc == endMarker2) {     // if a CR or LF was received
        receivedChars[ndx] = '\0';                    // terminate the character array (string)... 
        ndx = 0;
        newData = true;
        char temp =  Serial.read();
        goto ReturnReceivedString;                    // return everything 
      }
      else if (rc == 127) {                           // A DEL character (decimal 127) was received 
        ndx = ndx - 1;                              // Set the Array-Pointer back to delete the last character
        std::cout << rc;                           // Echo del DEL character back that the Terminal Client app 
      }                                             // removes the last character from the screen
      else {
        __out__=__out__+rc;
        receivedChars[ndx] = rc;                      // Receive normal characters...
        ndx++;
        if (ndx >= numChars) {
          ndx = numChars - 1;
        }
        
        if (HideEcho == false) {                      // Hide echo if user types in a password...
          //std::cout << rc;
          Serial.print(rc);
        }
        else {                                        // Normal echo
          std::cout <<"*";
        }
      }
    }// fine del blocco di acquisizione dei caratteri
    
  } // fine del blocco di lettura

  
 ReturnReceivedString:
   //return receivedChars;
  return __out__;
} // fine della funzione Ser_Rx()
